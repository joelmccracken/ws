#!/usr/bin/env bash

# prototype of a new workstation tool. goal being an interactive tool that can be used anywhere.
# I'm much better at bash now, and think I can probably accomplish what I need to do.

# ensure macos bash used: (export PATH="/bin:$PATH"; ./ws -v)
# (ensures that any other bash processes will use builtin too)
# set -euo pipefail

ws_script_dir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

# set -x

. "${ws_script_dir}/lib/settings.bash"
. "${ws_script_dir}/lib/logging.bash"
. "${ws_script_dir}/lib/properties.bash"
. "${ws_script_dir}/lib/bootstrap_doctor.bash"

__ret= # hack to use return values
ws_command=help # show help if nothing provided
declare -a ws_command_arguments
workstation_bootstrap_initial_config_dir=
workstation_name_arg=
workstation_settings_arg=
workstation_config_arg=

usage_and_quit() {
    print_usage
    exit "$1"
}

load_if_exists() {
  if [ -f "$1" ]; then
    . "$1"
  fi
}

load_expected() {
  if [ -f "$1" ]; then
    . "$1"
  else
    error "ws: init: expected to load file $1, but no file found"
  fi
}

print_usage() {
    echo "Workstation configuration tool."
    echo
    echo "Usage:"
    echo "  ws [options] bootstrap"
    echo "  ws [options] doctor"
    echo
    echo "Subcommands:"
    echo "  bootstrap     : run the bootstrap process"
    echo "  doctor        : Run checks on local setup"
    echo "  help          : display this message"
    echo
    echo "Options:"
    echo "-h --help                : Display this message and exit"
    echo "-v -verbose              : Be verbose"
    echo "-n NAME, --name NAME     : Specify the name of this workstation."
    echo "-s PATH, --settings PATH : Path to settings file to use."
    echo "-c PATH, --config PATH   : Path to configuration file."
    echo "-i, --interactive        : Interactive mode."
    echo "-b, --bootstrap-initial-config-dir:  Initial configuration directory."
    echo "       When first setting up a new workstation, admin can download"
    echo "       their user workstation configuration data, point ws at it,"
    echo "       and have ws move it into the target space during bootstrap."
}

process_cli_args() {
  local args=("${ws_command_arguments[@]}")
  local i;
  # i starts at 1 to skip past the first entry (static string "args")
  # this prevents array from being empty
  # I believe this is a consequences of set -u, but I don't know enough of the
  # tradeoffs to decide to do it differently
  for ((i=1;i < ${#args[@]}; i++)); do
    debug "iter:$i ; current:${args[i]} ; max:${#args[@]}"
    local current="${args[i]}"

    case "$current" in
      -v|--verbose)
        WORKSTATION_VERBOSE=true
        WORKSTATION_LOG_LEVEL=info
        ;;
      -n|--name)
        workstation_name_arg="${args[i+1]}";
        (( i+=1 ));
        ;;
      -c|--config)
        workstation_config_arg="${args[i+1]}";
        (( i+=1 ));
        ;;
      -b|--bootstrap-initial-config-dir)
        workstation_bootstrap_initial_config_dir_arg="${args[i+1]}";
        (( i+=1 ));
        ;;
      -s|--settings)
        workstation_settings_arg="${args[i+1]}";
        (( i+=1 ));
        ;;
      -h|--help|help)
        usage_and_quit 0;
        ;;
      -i|--interactive)
        workstation_interactive=true;
        ;;
      -*|--*)
        echo "Unknown option ${args[i]}";
        exit 1;
        ;;
      bootstrap)
        ws_command="$current";
        ;;
      doctor)
        ws_command="$current";
        ;;
      *)
        error "unknown option or subcommand '$current'";
        exit 10;
        ;;
    esac
  done

  return 0
}

help_command() {
  usage_and_quit 0;
}

ws_main() {
  ws_command_arguments=(args "$@") # save a copy
  # TODO should load these after processing args, as args can specify these paths
  # well i guess it does below; I need to think about this. what would the proper behavior be etc
  # like, if there was a file in the expected default location, _and_ a file is specified on the CLI,
  # as I have the code at this instant it would run both. Fine. but is that correct?
  # I guess i could document it either way. but what woudl be the "expected" behavior??
  load_if_exists "$WORKSTATION_CONFIG_FILE"
  load_if_exists "$WORKSTATION_SETTINGS_FILE"

  process_cli_args
  [ -n "$workstation_name_arg" ] && WORKSTATION_NAME="$workstation_name_arg"

  if [ "$WORKSTATION_VERBOSE" = "true" ]; then
    set -x
  fi

  [ -n "$workstation_settings_arg" ] && load_expected "$workstation_settings_arg"
  [ -n "$workstation_config_arg" ] && load_expected "$workstation_config_arg"

  case "$ws_command" in
    bootstrap) bootstrap_command;;
    doctor) doctor_command;;
    "help") help_command;;
    *) error "unknown command $ws_command; how did we get here?"
  esac
}

# if being run directly, run main
(return 0 2>/dev/null) || ws_main "$@"

